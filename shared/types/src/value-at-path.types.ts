/**
 * Handles object property access in a path
 * Returns the value type if we're at the end, otherwise continues recursing
 */
type HandleObjectAccess<T, Key, RemainingPath extends readonly any[]> = Key extends keyof T
	? RemainingPath['length'] extends 0
		? T[Key] // End of the path, return the value
		: GetValueAtPath<T[Key], RemainingPath> // Continue with the remaining path
	: never;

/**
 * Handles array index access in a path
 * Only works with numeric indices, not string keys
 */
type HandleArrayAccess<
	T extends readonly any[],
	Key,
	RemainingPath extends readonly any[],
> = Key extends number
	? RemainingPath['length'] extends 0
		? T[Key] // End of the path, return the array element
		: GetValueAtPath<T[Key], RemainingPath> // Continue with the remaining path
	: never;

/**
 * Processes a single step in the path traversal
 * Decides whether to handle as object property or array index
 */
type ProcessPathStep<T, Key, RemainingPath extends readonly any[]> = T extends readonly any[]
	? HandleArrayAccess<T, Key, RemainingPath>
	: HandleObjectAccess<T, Key, RemainingPath>;

/**
 * Gets the type of the value at a specific path in an object
 * Works with the paths generated by KeyPath
 *
 * @template T - The object type
 * @template P - The path tuple (e.g., ['user', 'profile', 'name'])
 */
export type GetValueAtPath<T, P extends readonly any[]> = P extends readonly [
	infer Head,
	...infer Tail,
]
	? Tail extends readonly any[]
		? ProcessPathStep<T, Head, Tail>
		: never
	: T; // empty path returns the original type
